<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epoch Server Ping Countdown</title>
    <style>
        body { background-color: #1a1a2e; color: #e0e0e0; font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; text-align: center; }
        .container { padding: 40px; background-color: #16213e; border-radius: 15px; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); }
        h1 { color: #0f3460; margin-top: 0; }
        #countdown { font-size: 4rem; font-weight: bold; color: #e94560; letter-spacing: 4px; }
        p { font-size: 1.2rem; }
        #status-text { font-size: 0.9rem; color: #aaa; min-height: 1.2em; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Epoch Server Status</h1>
        <p>Next server update is estimated in:</p>
        <div id="countdown">--:--</div>
        <p id="status-text">Fetching status from server...</p>
    </div>

    <script>
        const countdownElement = document.getElementById('countdown');
        const statusTextElement = document.getElementById('status-text');
        let countdownInterval;

        async function startCountdown() {
            try {
                // Step 1: Ask our backend for the last ping time
                const response = await fetch('/api/status');
                const data = await response.json();

                if (!data.lastPingTime) {
                    countdownElement.textContent = "??:??";
                    statusTextElement.textContent = "Waiting for the first server change to be detected...";
                    return; // Stop here if we don't have a time yet
                }

                // Step 2: Calculate when the next ping should happen (1 hour after the last one)
                const lastPing = new Date(data.lastPingTime);
                const nextPingTime = new Date(lastPing.getTime() + 60 * 60 * 1000); // Add 1 hour

                statusTextElement.textContent = `Last update detected at: ${lastPing.toLocaleTimeString()}`;

                // Clear any previous interval to prevent multiple timers running
                if (countdownInterval) clearInterval(countdownInterval);

                // Step 3: Start the countdown timer, updating every second
                countdownInterval = setInterval(() => {
                    const now = new Date();
                    const diff = nextPingTime - now;

                    if (diff <= 0) {
                        countdownElement.textContent = "00:00";
                        statusTextElement.textContent = "A new ping should have occurred. Awaiting detection...";
                        clearInterval(countdownInterval);
                        // Optional: re-fetch status after a few seconds
                        setTimeout(startCountdown, 5000); 
                        return;
                    }

                    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                    
                    countdownElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }, 1000);

            } catch (error) {
                console.error('Failed to fetch status:', error);
                statusTextElement.textContent = "Could not connect to the backend server.";
            }
        }

        // Start the whole process when the page loads
        startCountdown();
    </script>

</body>
</html>